"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isInsideQuotationMark = exports.suggestEqualSymbol = exports.buildDocumentation = exports.toCompletionItems = exports.convertAttributesToCompletionItems = exports.convertToCompletionItems = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
/**
 * Converts a json object containing labels and documentations to CompletionItems.
 */
function convertToCompletionItems(completionItems, itemKind) {
    const result = [];
    for (const item of completionItems) {
        let documentationString = undefined;
        if (item.documentation) {
            // If a "fullSignature" is provided, we want to show it in the completion item
            const documentationWithSignature = item.fullSignature && item.documentation
                ? ['```prisma', item.fullSignature, '```', '___', item.documentation].join('\n')
                : undefined;
            // If not we only show the documentation
            documentationString = documentationWithSignature ? documentationWithSignature : item.documentation;
        }
        result.push({
            label: item.label,
            kind: itemKind,
            insertText: item.insertText,
            insertTextFormat: item.insertText ? vscode_languageserver_1.InsertTextFormat.Snippet : vscode_languageserver_1.InsertTextFormat.PlainText,
            insertTextMode: item.insertText ? vscode_languageserver_1.InsertTextMode.adjustIndentation : undefined,
            documentation: documentationString ? { kind: vscode_languageserver_1.MarkupKind.Markdown, value: documentationString } : undefined,
        });
    }
    return result;
}
exports.convertToCompletionItems = convertToCompletionItems;
/**
 * Converts a json object containing attributes including function signatures to CompletionItems.
 */
function convertAttributesToCompletionItems(completionItems, itemKind) {
    const result = [];
    for (const item of completionItems) {
        const docComment = ['```prisma', item.fullSignature, '```', '___', item.documentation];
        for (const param of item.params) {
            docComment.push('', '_@param_ ' + param.label + ' ' + param.documentation);
        }
        result.push({
            label: item.label,
            kind: itemKind,
            insertText: item.insertText,
            insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
            insertTextMode: item.insertText ? vscode_languageserver_1.InsertTextMode.adjustIndentation : undefined,
            documentation: {
                kind: vscode_languageserver_1.MarkupKind.Markdown,
                value: docComment.join('\n'),
            },
        });
    }
    return result;
}
exports.convertAttributesToCompletionItems = convertAttributesToCompletionItems;
function toCompletionItems(allowedTypes, kind) {
    return allowedTypes.map((label) => ({ label, kind }));
}
exports.toCompletionItems = toCompletionItems;
const buildDocumentation = (element, documentation = '') => {
    if (element._number_of_optional_args !== 0) {
        documentation = `${documentation}Number of optional arguments: ${element._number_of_optional_args}.\n`;
    }
    if (element._number_of_args !== 0) {
        documentation = `${documentation}Number of required arguments: ${element._number_of_args}.\n`;
    }
    return documentation;
};
exports.buildDocumentation = buildDocumentation;
function suggestEqualSymbol(blockType) {
    if (!(blockType == 'datasource' || blockType == 'generator')) {
        return;
    }
    const equalSymbol = { label: '=' };
    return {
        items: [equalSymbol],
        isIncomplete: false,
    };
}
exports.suggestEqualSymbol = suggestEqualSymbol;
/***
 * Checks if inside e.g. "here"
 * Does not check for escaped quotation marks.
 */
function isInsideQuotationMark(currentLineUntrimmed, position) {
    let insideQuotation = false;
    for (let i = 0; i < position.character; i++) {
        if (currentLineUntrimmed[i] === '"') {
            insideQuotation = !insideQuotation;
        }
    }
    return insideQuotation;
}
exports.isInsideQuotationMark = isInsideQuotationMark;
//# sourceMappingURL=internals.js.map
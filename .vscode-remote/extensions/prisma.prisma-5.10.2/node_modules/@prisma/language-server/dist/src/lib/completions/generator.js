"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generatorSuggestions = exports.getSuggestionForGeneratorField = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const completions = __importStar(require("./completions.json"));
const ast_1 = require("../ast");
const internals_1 = require("./internals");
const klona_1 = require("klona");
const listAllAvailablePreviewFeatures_1 = __importDefault(require("../prisma-schema-wasm/listAllAvailablePreviewFeatures"));
/**
 * ```prisma
 * generator client {
 *  |
 * }
 * ```
 */
const supportedGeneratorFields = (0, internals_1.convertToCompletionItems)(completions.generatorFields, vscode_languageserver_1.CompletionItemKind.Field);
// generator.provider
const generatorProviders = (0, internals_1.convertToCompletionItems)(completions.generatorProviders, vscode_languageserver_1.CompletionItemKind.Constant);
/**
 * ```prisma
 * generator client {
 *  provider = "|"
 * }
 * ```
 */
const generatorProviderArguments = (0, internals_1.convertToCompletionItems)(completions.generatorProviderArguments, vscode_languageserver_1.CompletionItemKind.Property);
// generator.engineType
const engineTypes = (0, internals_1.convertToCompletionItems)(completions.engineTypes, vscode_languageserver_1.CompletionItemKind.Constant);
/**
 * ```prisma
 * generator client {
 *  engineType = "|"
 * }
 * ```
 */
const engineTypeArguments = (0, internals_1.convertToCompletionItems)(completions.engineTypeArguments, vscode_languageserver_1.CompletionItemKind.Property);
/**
 * ```prisma
 * generator client {
 *  previewFeatures = ["|"]
 * }
 * ```
 */
const previewFeaturesArguments = (0, internals_1.convertToCompletionItems)(completions.previewFeaturesArguments, vscode_languageserver_1.CompletionItemKind.Property);
function handlePreviewFeatures(previewFeaturesArray, position, currentLineUntrimmed, isInsideQuotation) {
    let previewFeatures = previewFeaturesArray.map((pf) => vscode_languageserver_1.CompletionItem.create(pf));
    if ((0, ast_1.isInsideAttribute)(currentLineUntrimmed, position, '[]')) {
        if (isInsideQuotation) {
            const usedValues = (0, ast_1.getValuesInsideSquareBrackets)(currentLineUntrimmed);
            previewFeatures = previewFeatures.filter((t) => !usedValues.includes(t.label));
            return {
                items: previewFeatures,
                isIncomplete: true,
            };
        }
        else {
            return {
                items: previewFeaturesArguments.filter((arg) => !arg.label.includes('[')),
                isIncomplete: true,
            };
        }
    }
    else {
        return {
            items: previewFeaturesArguments.filter((arg) => !arg.label.includes('"')),
            isIncomplete: true,
        };
    }
}
/**
 * Removes all field suggestion that are invalid in this context. E.g. fields that are used already in a block will not be suggested again.
 * This function removes all field suggestion that are invalid in a certain context. E.g. in a generator block `provider, output, platforms, pinnedPlatForm`
 * are possible fields. But those fields are only valid suggestions if they haven't been used in this block yet. So in case `provider` has already been used, only
 * `output, platforms, pinnedPlatform` will be suggested.
 */
function removeInvalidFieldSuggestions(supportedFields, block, lines, position) {
    let reachedStartLine = false;
    for (const [key, item] of lines.entries()) {
        if (key === block.range.start.line + 1) {
            reachedStartLine = true;
        }
        if (!reachedStartLine || key === position.line) {
            continue;
        }
        if (key === block.range.end.line) {
            break;
        }
        const fieldName = item.replace(/ .*/, '');
        if (supportedFields.includes(fieldName)) {
            supportedFields = supportedFields.filter((field) => field !== fieldName);
        }
    }
    return supportedFields;
}
function getSuggestionForGeneratorField(block, lines, position) {
    // create deep copy
    const suggestions = (0, klona_1.klona)(supportedGeneratorFields);
    const labels = removeInvalidFieldSuggestions(suggestions.map((item) => item.label), block, lines, position);
    return suggestions.filter((item) => labels.includes(item.label));
}
exports.getSuggestionForGeneratorField = getSuggestionForGeneratorField;
const generatorSuggestions = (line, untrimmedLine, position, isInsideQuotation, onError) => {
    // provider
    if (line.startsWith('provider')) {
        const providers = generatorProviders;
        if (isInsideQuotation) {
            return {
                items: providers,
                isIncomplete: true,
            };
        }
        else {
            return {
                items: generatorProviderArguments,
                isIncomplete: true,
            };
        }
    }
    // previewFeatures
    else if (line.startsWith('previewFeatures')) {
        const generatorPreviewFeatures = (0, listAllAvailablePreviewFeatures_1.default)(onError);
        if (generatorPreviewFeatures.length > 0) {
            return handlePreviewFeatures(generatorPreviewFeatures, position, untrimmedLine, isInsideQuotation);
        }
    }
    // engineType
    else if (line.startsWith('engineType')) {
        const engineTypesCompletion = engineTypes;
        if (isInsideQuotation) {
            return {
                items: engineTypesCompletion,
                isIncomplete: true,
            };
        }
        else {
            return {
                items: engineTypeArguments,
                isIncomplete: true,
            };
        }
    }
};
exports.generatorSuggestions = generatorSuggestions;
//# sourceMappingURL=generator.js.map
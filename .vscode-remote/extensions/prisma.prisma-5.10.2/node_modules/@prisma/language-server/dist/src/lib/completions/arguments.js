"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCompletionsForBlockAttributeArgs = exports.getCompletionsForFieldAttributeArgs = exports.filterSortLengthBasedOnInput = exports.booleanDefaultCompletions = exports.scalarListDefaultCompletion = exports.startSequenceDefaultCompletion = exports.incrementSequenceDefaultCompletion = exports.cacheSequenceDefaultCompletion = exports.maxValueSequenceDefaultCompletion = exports.minValueSequenceDefaultCompletion = exports.virtualSequenceDefaultCompletion = exports.opsIndexFulltextCompletion = exports.relationArguments = exports.sortLengthProperties = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const internals_1 = require("./internals");
const completions = __importStar(require("./completions.json"));
exports.sortLengthProperties = (0, internals_1.convertToCompletionItems)(
// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
completions.fieldAttributes
    .find((item) => item.label === '@unique')
    .params.filter((item) => item.label === 'length' || item.label === 'sort'), vscode_languageserver_1.CompletionItemKind.Property);
exports.relationArguments = (0, internals_1.convertAttributesToCompletionItems)(completions.relationArguments, vscode_languageserver_1.CompletionItemKind.Property);
const sqlServerClusteredValuesCompletionItems = [
    {
        label: 'true',
        kind: vscode_languageserver_1.CompletionItemKind.Value,
        insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
        documentation: {
            kind: 'markdown',
            value: 'CLUSTERED',
        },
    },
    {
        label: 'false',
        kind: vscode_languageserver_1.CompletionItemKind.Value,
        insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
        documentation: {
            kind: 'markdown',
            value: 'NONCLUSTERED',
        },
    },
];
/**
 * ```prisma
 * model A {
 *  id    Int @id
 *  field Int @unique(sort: |)
 *  otherField Int
 *
 *  \@@unique(fields: [otherField(sort: |)])
 *  \@@index(fields: [id(sort: |)])
 * }
 * ```
 * And then specifically Sql Server, we also return:
 * ```prisma
 *  model A {
 *  id    Int @id(sort: |)
 *
 *  \@@id(fields: [id(sort: |)])
 * }
 * ```
 */
const sortValuesCompletionItems = [
    {
        label: 'Asc',
        kind: vscode_languageserver_1.CompletionItemKind.Enum,
        insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
        documentation: {
            kind: 'markdown',
            value: 'Ascending',
        },
    },
    {
        label: 'Desc',
        kind: vscode_languageserver_1.CompletionItemKind.Enum,
        insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
        documentation: {
            kind: 'markdown',
            value: 'Descending',
        },
    },
];
const clusteredCompletion = (items) => items.push({
    label: 'clustered',
    insertText: 'clustered: $0',
    insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
    kind: vscode_languageserver_1.CompletionItemKind.Property,
    documentation: 'An index, unique constraint or primary key can be created as clustered or non-clustered; altering the storage and retrieve behavior of the index.',
});
const typeIndexCompletion = (items) => items.push({
    label: 'type',
    kind: vscode_languageserver_1.CompletionItemKind.Property,
    insertText: 'type: $0',
    insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
    insertTextMode: vscode_languageserver_1.InsertTextMode.adjustIndentation,
    documentation: {
        kind: 'markdown',
        value: 'Defines the access type of indexes: BTree (default) or Hash.',
    },
});
const opsIndexFulltextCompletion = (items) => items.push({
    label: 'ops',
    insertText: 'ops: $0',
    insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
    kind: vscode_languageserver_1.CompletionItemKind.Property,
    documentation: 'Specify the operator class for an indexed field.',
});
exports.opsIndexFulltextCompletion = opsIndexFulltextCompletion;
//#region COCKROACHDB ONLY
const virtualSequenceDefaultCompletion = (items) => items.push({
    label: 'virtual',
    insertText: 'virtual',
    kind: vscode_languageserver_1.CompletionItemKind.Property,
    documentation: 'Virtual sequences are sequences that do not generate monotonically increasing values and instead produce values like those generated by the built-in function unique_rowid(). They are intended for use in combination with SERIAL-typed columns.',
});
exports.virtualSequenceDefaultCompletion = virtualSequenceDefaultCompletion;
const minValueSequenceDefaultCompletion = (items) => items.push({
    label: 'minValue',
    insertText: 'minValue: $0',
    insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
    kind: vscode_languageserver_1.CompletionItemKind.Property,
    documentation: 'The new minimum value of the sequence.',
});
exports.minValueSequenceDefaultCompletion = minValueSequenceDefaultCompletion;
const maxValueSequenceDefaultCompletion = (items) => items.push({
    label: 'maxValue',
    insertText: 'maxValue: $0',
    insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
    kind: vscode_languageserver_1.CompletionItemKind.Property,
    documentation: 'The new maximum value of the sequence.',
});
exports.maxValueSequenceDefaultCompletion = maxValueSequenceDefaultCompletion;
const cacheSequenceDefaultCompletion = (items) => items.push({
    label: 'cache',
    insertText: 'cache: $0',
    insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
    kind: vscode_languageserver_1.CompletionItemKind.Property,
    documentation: 'The number of sequence values to cache in memory for reuse in the session. A cache size of 1 means that there is no cache, and cache sizes of less than 1 are not valid.',
});
exports.cacheSequenceDefaultCompletion = cacheSequenceDefaultCompletion;
const incrementSequenceDefaultCompletion = (items) => items.push({
    label: 'increment',
    insertText: 'increment: $0',
    insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
    kind: vscode_languageserver_1.CompletionItemKind.Property,
    documentation: 'The new value by which the sequence is incremented. A negative number creates a descending sequence. A positive number creates an ascending sequence.',
});
exports.incrementSequenceDefaultCompletion = incrementSequenceDefaultCompletion;
const startSequenceDefaultCompletion = (items) => items.push({
    label: 'start',
    insertText: 'start: $0',
    insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
    kind: vscode_languageserver_1.CompletionItemKind.Property,
    documentation: 'The value the sequence starts at if you RESTART or if the sequence hits the MAXVALUE and CYCLE is set.',
});
exports.startSequenceDefaultCompletion = startSequenceDefaultCompletion;
//#endregion
const scalarListDefaultCompletion = (items) => items.unshift({
    label: '[]',
    insertText: '[$0]',
    insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
    documentation: 'Set a default value on the list field',
    kind: vscode_languageserver_1.CompletionItemKind.Value,
});
exports.scalarListDefaultCompletion = scalarListDefaultCompletion;
const booleanDefaultCompletions = (items) => items.push({ label: 'true', kind: vscode_languageserver_1.CompletionItemKind.Value }, { label: 'false', kind: vscode_languageserver_1.CompletionItemKind.Value });
exports.booleanDefaultCompletions = booleanDefaultCompletions;
function filterSortLengthBasedOnInput(attribute, previewFeatures, datasourceProvider, wordBeforePosition, items) {
    /*
     * 1 - Autocomplete values
     */
    // Auto completion for sort: Desc | Asc
    // includes because `@unique(sort: |)` means wordBeforePosition = '@unique(sort:'
    if (wordBeforePosition.includes('sort:')) {
        return sortValuesCompletionItems;
    }
    else {
        /*
         * 2 - Autocomplete properties
         */
        // The length argument is available on MySQL only on the
        // @id, @@id, @unique, @@unique and @@index fields.
        // The sort argument is available for all databases on the
        // @unique, @@unique and @@index fields.
        // Additionally, SQL Server also allows it on @id and @@id.
        // Which translates too
        // - `length` argument for `@id`, `@@id`, `@unique`, `@@unique` and `@@index` (MySQL only)
        // - Note that on the `@@` the argument is on available a field - not on the top level attribute
        // - `sort` argument for `@unique`, `@@unique` and `@@index` (Additionally `@id` and `@@id` for SQL Server)
        if (datasourceProvider === 'mysql') {
            if (['@unique', '@@unique', '@@index'].includes(attribute)) {
                return items;
            }
            else {
                // filter sort out
                return items.filter((arg) => arg.label !== 'sort');
            }
        }
        else if (datasourceProvider === 'sqlserver') {
            if (['@unique', '@@unique', '@@index', '@id', '@@id'].includes(attribute)) {
                // only filter length out
                return items.filter((arg) => arg.label !== 'length');
            }
            else {
                // filter length and sort out
                return items.filter((arg) => arg.label !== 'length' && arg.label !== 'sort');
            }
        }
        else {
            if (['@unique', '@@unique', '@@index'].includes(attribute)) {
                // only filter length out
                return items.filter((arg) => arg.label !== 'length');
            }
            else {
                // filter length and sort out
                return items.filter((arg) => arg.label !== 'length' && arg.label !== 'sort');
            }
        }
    }
}
exports.filterSortLengthBasedOnInput = filterSortLengthBasedOnInput;
function getCompletionsForFieldAttributeArgs(fieldAttributeWithParams, previewFeatures, datasourceProvider, wordBeforePosition) {
    const items = (0, internals_1.convertToCompletionItems)(
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    completions.fieldAttributes.find((item) => item.label.includes(fieldAttributeWithParams)).params, vscode_languageserver_1.CompletionItemKind.Property);
    const completionItems = filterSortLengthBasedOnInput(fieldAttributeWithParams, previewFeatures, datasourceProvider, wordBeforePosition, items);
    if (datasourceProvider === 'sqlserver') {
        // Auto completion for SQL Server only, clustered: true | false
        if (wordBeforePosition.includes('clustered:')) {
            return sqlServerClusteredValuesCompletionItems;
        }
        // add clustered propery to completion items
        completionItems.push({
            label: 'clustered',
            insertText: 'clustered: $0',
            insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
            kind: vscode_languageserver_1.CompletionItemKind.Property,
            documentation: 'An index, unique constraint or primary key can be created as clustered or non-clustered; altering the storage and retrieve behavior of the index.',
        });
    }
    return completionItems;
}
exports.getCompletionsForFieldAttributeArgs = getCompletionsForFieldAttributeArgs;
function getCompletionsForBlockAttributeArgs({ blockAttributeWithParams, wordBeforePosition, datasourceProvider, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
previewFeatures, }) {
    const items = (0, internals_1.convertToCompletionItems)(
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    completions.blockAttributes.find((item) => item.label.includes(blockAttributeWithParams)).params, vscode_languageserver_1.CompletionItemKind.Property);
    // SQL Server only, suggest clustered
    if (datasourceProvider === 'sqlserver' && blockAttributeWithParams !== '@@fulltext') {
        // Auto completion for SQL Server only, clustered: true | false
        if (wordBeforePosition.includes('clustered:')) {
            return sqlServerClusteredValuesCompletionItems;
        }
        else {
            // add clustered to suggestions
            clusteredCompletion(items);
        }
    }
    // PostgreSQL only, suggest type
    else if (blockAttributeWithParams === '@@index' &&
        datasourceProvider &&
        ['postgresql', 'postgres'].includes(datasourceProvider)) {
        // TODO (Joël) figure out if we need to add cockroachdb provider here
        // The type argument is only available for PostgreSQL on @@index
        typeIndexCompletion(items);
    }
    return items;
}
exports.getCompletionsForBlockAttributeArgs = getCompletionsForBlockAttributeArgs;
//# sourceMappingURL=arguments.js.map
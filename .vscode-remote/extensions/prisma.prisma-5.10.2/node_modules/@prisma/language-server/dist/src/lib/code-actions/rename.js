"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractCurrentName = exports.insertMapAttribute = exports.mapExistsAlready = exports.insertBasicRename = exports.renameReferencesForModelName = exports.renameReferencesForEnumValue = exports.renameReferencesForFieldName = exports.printLogMessage = exports.isEnumValue = exports.isDatamodelBlockName = exports.isValidFieldName = exports.isRelationField = void 0;
const ast_1 = require("../ast");
const constants_1 = require("../constants");
function getType(currentLine) {
    const wordsInLine = currentLine.split(/\s+/);
    if (wordsInLine.length < 2) {
        return '';
    }
    return wordsInLine[1].replace('?', '').replace('[]', '');
}
function isRelationField(currentLine, lines) {
    const relationNames = (0, ast_1.getAllRelationNames)(lines, constants_1.relationNamesRegexFilter);
    const type = getType(currentLine);
    if (type == '') {
        return false;
    }
    return relationNames.includes(type);
}
exports.isRelationField = isRelationField;
function extractFirstWord(line) {
    return line.replace(/ .*/, '');
}
function isValidFieldName(currentLine, position, block, document) {
    if (block.type === 'datasource' ||
        block.type === 'generator' ||
        block.type === 'enum' ||
        position.line == block.range.start.line ||
        position.line == block.range.end.line) {
        return false;
    }
    if (currentLine.startsWith('@')) {
        return false;
    }
    // check if position is inside first word
    const currentLineUntrimmed = (0, ast_1.getCurrentLine)(document, position.line);
    const firstWord = extractFirstWord(currentLine);
    const indexOfFirstWord = currentLineUntrimmed.indexOf(firstWord);
    const isFieldName = indexOfFirstWord <= position.character && indexOfFirstWord + firstWord.length >= position.character;
    if (!isFieldName) {
        return false;
    }
    // remove type modifiers
    const type = getType(currentLine);
    return type !== '' && type !== undefined;
}
exports.isValidFieldName = isValidFieldName;
const isDatamodelBlockName = (position, block, lines, document) => {
    // TODO figure out how to use DatamodelBlockType
    if (!['model', 'view', 'type', 'enum'].includes(block.type)) {
        return false;
    }
    if (position.line !== block.range.start.line) {
        return renameDatamodelBlockWhereUsedAsType(block, lines, document, position);
    }
    switch (block.type) {
        case 'model':
            return position.character > 5;
        case 'enum':
        case 'view':
        case 'type':
            return position.character > 4;
        default:
            return false;
    }
};
exports.isDatamodelBlockName = isDatamodelBlockName;
function renameDatamodelBlockWhereUsedAsType(block, lines, document, position) {
    // TODO type?
    if (block.type !== 'model') {
        return false;
    }
    const allRelationNames = (0, ast_1.getAllRelationNames)(lines, constants_1.relationNamesRegexFilter);
    const currentName = (0, ast_1.getWordAtPosition)(document, position);
    const isRelation = allRelationNames.includes(currentName);
    if (!isRelation) {
        return false;
    }
    const indexOfRelation = lines.findIndex((l) => l.startsWith(block.type) && l.includes(currentName));
    return indexOfRelation !== -1;
}
function isEnumValue(line, position, block, document) {
    return (block.type === 'enum' &&
        position.line !== block.range.start.line &&
        !line.startsWith('@@') &&
        !(0, ast_1.getWordAtPosition)(document, position).startsWith('@'));
}
exports.isEnumValue = isEnumValue;
function printLogMessage(currentName, newName, isBlockRename, isFieldRename, isEnumValueRename, blockType) {
    const message = `'${currentName}' was renamed to '${newName}'`;
    let typeOfRename = '';
    if (isBlockRename) {
        typeOfRename = `${blockType} `;
    }
    else if (isFieldRename) {
        typeOfRename = 'Field ';
    }
    else if (isEnumValueRename) {
        typeOfRename = 'Enum value ';
    }
    console.log(typeOfRename + message);
}
exports.printLogMessage = printLogMessage;
function insertInlineRename(currentName, line) {
    return {
        range: {
            start: {
                line: line,
                character: constants_1.MAX_SAFE_VALUE_i32,
            },
            end: {
                line: line,
                character: constants_1.MAX_SAFE_VALUE_i32,
            },
        },
        newText: ` @map("${currentName}")`,
    };
}
function insertMapBlockAttribute(oldName, block) {
    return {
        range: {
            start: {
                line: block.range.end.line,
                character: 0,
            },
            end: block.range.end,
        },
        newText: `\t@@map("${oldName}")\n}`,
    };
}
function positionIsNotInsideSearchedBlocks(line, searchedBlocks) {
    if (searchedBlocks.length === 0) {
        return true;
    }
    return !searchedBlocks.some((block) => line >= block.range.start.line && line <= block.range.end.line);
}
/**
 * Renames references in any '@@index', '@@id' and '@@unique' attributes in the same model.
 * Renames references in any referenced fields inside a '@relation' attribute in the same model (fields: []).
 * Renames references inside a '@relation' attribute in other model blocks (references: []).
 */
function renameReferencesForFieldName(currentName, newName, document, lines, block, isRelationFieldRename) {
    const edits = [];
    const searchStringsSameBlock = ['@@index', '@@id', '@@unique'];
    const relationAttribute = '@relation';
    // search in same model first
    let reachedStartLine = false;
    for (const [key, item] of lines.entries()) {
        if (key === block.range.start.line + 1) {
            reachedStartLine = true;
        }
        if (!reachedStartLine) {
            continue;
        }
        if (key === block.range.end.line) {
            break;
        }
        if (item.includes(relationAttribute) && item.includes(currentName) && !isRelationFieldRename) {
            // search for fields references
            const currentLineUntrimmed = (0, ast_1.getCurrentLine)(document, key);
            const indexOfFieldsStart = currentLineUntrimmed.indexOf('fields:');
            const indexOfFieldEnd = currentLineUntrimmed.slice(indexOfFieldsStart).indexOf(']') + indexOfFieldsStart;
            const fields = currentLineUntrimmed.slice(indexOfFieldsStart, indexOfFieldEnd + 1);
            const indexOfFoundValue = fields.indexOf(currentName);
            const fieldValues = (0, ast_1.getValuesInsideSquareBrackets)(fields);
            if (indexOfFoundValue !== -1 && fieldValues.includes(currentName)) {
                // found a referenced field
                edits.push({
                    range: {
                        start: {
                            line: key,
                            character: indexOfFieldsStart + indexOfFoundValue,
                        },
                        end: {
                            line: key,
                            character: indexOfFieldsStart + indexOfFoundValue + currentName.length,
                        },
                    },
                    newText: newName,
                });
            }
        }
        // search for references in index, id and unique block attributes
        if (searchStringsSameBlock.some((s) => item.includes(s)) && item.includes(currentName)) {
            const currentLineUntrimmed = (0, ast_1.getCurrentLine)(document, key);
            const valuesInsideBracket = (0, ast_1.getValuesInsideSquareBrackets)(currentLineUntrimmed);
            if (valuesInsideBracket.includes(currentName)) {
                const indexOfCurrentValue = currentLineUntrimmed.indexOf(currentName);
                edits.push({
                    range: {
                        start: {
                            line: key,
                            character: indexOfCurrentValue,
                        },
                        end: {
                            line: key,
                            character: indexOfCurrentValue + currentName.length,
                        },
                    },
                    newText: newName,
                });
            }
        }
    }
    // search for references in other model blocks
    for (const [index, value] of lines.entries()) {
        if (value.includes(block.name) && value.includes(currentName) && value.includes(relationAttribute)) {
            const currentLineUntrimmed = (0, ast_1.getCurrentLine)(document, index);
            // get the index of the second word
            const indexOfReferences = currentLineUntrimmed.indexOf('references:');
            const indexOfReferencesEnd = currentLineUntrimmed.slice(indexOfReferences).indexOf(']') + indexOfReferences;
            const references = currentLineUntrimmed.slice(indexOfReferences, indexOfReferencesEnd + 1);
            const indexOfFoundValue = references.indexOf(currentName);
            const referenceValues = (0, ast_1.getValuesInsideSquareBrackets)(references);
            if (indexOfFoundValue !== -1 && referenceValues.includes(currentName)) {
                edits.push({
                    range: {
                        start: {
                            line: index,
                            character: indexOfReferences + indexOfFoundValue,
                        },
                        end: {
                            line: index,
                            character: indexOfReferences + indexOfFoundValue + currentName.length,
                        },
                    },
                    newText: newName,
                });
            }
        }
    }
    return edits;
}
exports.renameReferencesForFieldName = renameReferencesForFieldName;
/**
 * Renames references where the current enum value is used as a default value in other model blocks.
 */
function renameReferencesForEnumValue(currentValue, newName, document, lines, enumName) {
    const edits = [];
    const searchString = `@default(${currentValue})`;
    for (const [index, value] of lines.entries()) {
        if (value.includes(searchString) && value.includes(enumName)) {
            const currentLineUntrimmed = (0, ast_1.getCurrentLine)(document, index);
            // get the index of the second word
            const indexOfCurrentName = currentLineUntrimmed.indexOf(searchString);
            edits.push({
                range: {
                    start: {
                        line: index,
                        character: indexOfCurrentName,
                    },
                    end: {
                        line: index,
                        character: indexOfCurrentName + searchString.length,
                    },
                },
                newText: `@default(${newName})`,
            });
        }
    }
    return edits;
}
exports.renameReferencesForEnumValue = renameReferencesForEnumValue;
/**
 * Renames references where the model name is used as a relation type in the same and other model blocks.
 */
function renameReferencesForModelName(currentName, newName, document, lines) {
    const searchedBlocks = [];
    const edits = [];
    for (const [index, value] of lines.entries()) {
        // check if inside model
        if (value.includes(currentName) && positionIsNotInsideSearchedBlocks(index, searchedBlocks)) {
            const block = (0, ast_1.getBlockAtPosition)(index, lines);
            // TODO type here
            if (block && block.type == 'model') {
                searchedBlocks.push(block);
                // search for field types in current block
                const fieldTypes = (0, ast_1.getFieldTypesFromCurrentBlock)(lines, block);
                for (const fieldType of fieldTypes.fieldTypes.keys()) {
                    if (fieldType.replace('?', '').replace('[]', '') === currentName) {
                        // replace here
                        const foundFieldTypes = fieldTypes.fieldTypes.get(fieldType);
                        if (!(foundFieldTypes === null || foundFieldTypes === void 0 ? void 0 : foundFieldTypes.lineIndexes)) {
                            return edits;
                        }
                        for (const lineIndex of foundFieldTypes.lineIndexes) {
                            const currentLineUntrimmed = (0, ast_1.getCurrentLine)(document, lineIndex);
                            const wordsInLine = lines[lineIndex].split(/\s+/);
                            // get the index of the second word
                            const indexOfFirstWord = currentLineUntrimmed.indexOf(wordsInLine[0]);
                            const indexOfCurrentName = currentLineUntrimmed.indexOf(currentName, indexOfFirstWord + wordsInLine[0].length);
                            edits.push({
                                range: {
                                    start: {
                                        line: lineIndex,
                                        character: indexOfCurrentName,
                                    },
                                    end: {
                                        line: lineIndex,
                                        character: indexOfCurrentName + currentName.length,
                                    },
                                },
                                newText: newName,
                            });
                        }
                    }
                }
            }
        }
    }
    return edits;
}
exports.renameReferencesForModelName = renameReferencesForModelName;
function mapFieldAttributeExistsAlready(line) {
    return line.includes('@map(');
}
function mapBlockAttributeExistsAlready(block, lines) {
    let reachedStartLine = false;
    for (const [key, item] of lines.entries()) {
        if (key === block.range.start.line + 1) {
            reachedStartLine = true;
        }
        if (!reachedStartLine) {
            continue;
        }
        if (key === block.range.end.line) {
            break;
        }
        if (item.startsWith('@@map(')) {
            return true;
        }
    }
    return false;
}
function insertBasicRename(newName, currentName, document, line) {
    const currentLineUntrimmed = (0, ast_1.getCurrentLine)(document, line);
    const indexOfCurrentName = currentLineUntrimmed.indexOf(currentName);
    return {
        range: {
            start: {
                line: line,
                character: indexOfCurrentName,
            },
            end: {
                line: line,
                character: indexOfCurrentName + currentName.length,
            },
        },
        newText: newName,
    };
}
exports.insertBasicRename = insertBasicRename;
function mapExistsAlready(currentLine, lines, block, isDatamodelBlockRename) {
    if (isDatamodelBlockRename) {
        return mapBlockAttributeExistsAlready(block, lines);
    }
    else {
        return mapFieldAttributeExistsAlready(currentLine);
    }
}
exports.mapExistsAlready = mapExistsAlready;
function insertMapAttribute(currentName, position, block, isDatamodelBlockRename) {
    if (isDatamodelBlockRename) {
        return insertMapBlockAttribute(currentName, block);
    }
    else {
        return insertInlineRename(currentName, position.line);
    }
}
exports.insertMapAttribute = insertMapAttribute;
function extractCurrentName(line, isBlockRename, isEnumValueRename, isFieldRename, document, position) {
    if (isBlockRename) {
        const currentLineUntrimmed = (0, ast_1.getCurrentLine)(document, position.line);
        const currentLineTillPosition = currentLineUntrimmed
            .slice(0, position.character + currentLineUntrimmed.slice(position.character).search(/\W/))
            .trim();
        const wordsBeforePosition = currentLineTillPosition.split(/\s+/);
        if (wordsBeforePosition.length < 2) {
            return '';
        }
        return wordsBeforePosition[1];
    }
    if (isEnumValueRename || isFieldRename) {
        return extractFirstWord(line);
    }
    return '';
}
exports.extractCurrentName = extractCurrentName;
//# sourceMappingURL=rename.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleDocumentSymbol = exports.handleCodeActions = exports.handleCompletionResolveRequest = exports.handleRenameRequest = exports.handleCompletionRequest = exports.handleHoverRequest = exports.handleDocumentFormatting = exports.handleDefinitionRequest = exports.handleDiagnosticsRequest = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const format_1 = __importDefault(require("./prisma-schema-wasm/format"));
const lint_1 = __importDefault(require("./prisma-schema-wasm/lint"));
const ast_1 = require("./ast");
const code_actions_1 = require("./code-actions");
const rename_1 = require("./code-actions/rename");
const validations_1 = require("./validations");
const ast_2 = require("./ast");
const completions_1 = require("./completions");
function handleDiagnosticsRequest(document, onError) {
    const text = document.getText((0, ast_2.fullDocumentRange)(document));
    const res = (0, lint_1.default)(text, (errorMessage) => {
        if (onError) {
            onError(errorMessage);
        }
    });
    const diagnostics = [];
    if (res.some((diagnostic) => diagnostic.text === "Field declarations don't require a `:`." ||
        diagnostic.text === 'Model declarations have to be indicated with the `model` keyword.')) {
        if (onError) {
            onError("You might currently be viewing a Prisma 1 datamodel which is based on the GraphQL syntax. The current Prisma Language Server doesn't support this syntax. If you are handling a Prisma 1 datamodel, please change the file extension to `.graphql` so the new Prisma Language Server does not get triggered anymore.");
        }
    }
    for (const diag of res) {
        const previewNotKnownRegex = /The preview feature \"[a-zA-Z]+\" is not known/;
        const diagnostic = {
            range: {
                start: document.positionAt(diag.start),
                end: document.positionAt(diag.end),
            },
            message: previewNotKnownRegex.test(diag.text)
                ? `${diag.text}.\nIf this is unexpected, it might be due to your Prisma VS Code Extension being out of date.`
                : diag.text,
            source: 'Prisma',
        };
        if (diag.is_warning) {
            diagnostic.severity = vscode_languageserver_1.DiagnosticSeverity.Warning;
        }
        else {
            diagnostic.severity = vscode_languageserver_1.DiagnosticSeverity.Error;
        }
        diagnostics.push(diagnostic);
    }
    (0, validations_1.validateExperimentalFeatures)(document, diagnostics);
    const lines = (0, ast_1.convertDocumentTextToTrimmedLineArray)(document);
    (0, validations_1.validateIgnoredBlocks)(lines, diagnostics);
    return diagnostics;
}
exports.handleDiagnosticsRequest = handleDiagnosticsRequest;
/**
 * @todo Use official schema.prisma parser. This is a workaround!
 */
function handleDefinitionRequest(document, params) {
    const textDocument = params.textDocument;
    const position = params.position;
    const lines = (0, ast_1.convertDocumentTextToTrimmedLineArray)(document);
    const word = (0, ast_2.getWordAtPosition)(document, position);
    if (word === '') {
        return;
    }
    // get start position of block
    const results = lines
        .map((line, index) => {
        if ((line.includes('model') && line.includes(word)) ||
            (line.includes('type') && line.includes(word)) ||
            (line.includes('enum') && line.includes(word))) {
            return index;
        }
    })
        .filter((index) => index !== undefined);
    if (results.length === 0) {
        return;
    }
    const foundBlocks = results
        .map((result) => {
        const block = (0, ast_2.getBlockAtPosition)(result, lines);
        if (block && block.name === word && block.range.start.line === result) {
            return block;
        }
    })
        .filter((block) => block !== undefined);
    if (foundBlocks.length !== 1) {
        return;
    }
    if (!foundBlocks[0]) {
        return;
    }
    return [
        {
            targetUri: textDocument.uri,
            targetRange: foundBlocks[0].range,
            targetSelectionRange: foundBlocks[0].nameRange,
        },
    ];
}
exports.handleDefinitionRequest = handleDefinitionRequest;
/**
 * This handler provides the modification to the document to be formatted.
 */
function handleDocumentFormatting(params, document, onError) {
    const formatted = (0, format_1.default)(document.getText(), params, onError);
    return [vscode_languageserver_1.TextEdit.replace((0, ast_2.fullDocumentRange)(document), formatted)];
}
exports.handleDocumentFormatting = handleDocumentFormatting;
function handleHoverRequest(document, params) {
    const position = params.position;
    const lines = (0, ast_1.convertDocumentTextToTrimmedLineArray)(document);
    const word = (0, ast_2.getWordAtPosition)(document, position);
    if (word === '') {
        return;
    }
    const block = (0, ast_2.getDatamodelBlock)(word, lines);
    if (!block) {
        return;
    }
    const blockDocumentation = (0, ast_2.getDocumentationForBlock)(document, block);
    if (blockDocumentation.length !== 0) {
        return {
            contents: blockDocumentation.join('\n\n'),
        };
    }
    // TODO uncomment once https://github.com/prisma/prisma/issues/2546 is resolved!
    /*if (docComments.startsWith('//')) {
      return {
        contents: docComments.slice(3).trim(),
      }
    } */
    return;
}
exports.handleHoverRequest = handleHoverRequest;
/**
 *
 * This handler provides the initial list of the completion items.
 */
function handleCompletionRequest(params, document, onError) {
    return (0, completions_1.prismaSchemaWasmCompletions)(params, document, onError) || (0, completions_1.localCompletions)(params, document, onError);
}
exports.handleCompletionRequest = handleCompletionRequest;
function handleRenameRequest(params, document) {
    const lines = (0, ast_1.convertDocumentTextToTrimmedLineArray)(document);
    const position = params.position;
    const currentLine = lines[position.line];
    const block = (0, ast_2.getBlockAtPosition)(position.line, lines);
    if (!block) {
        return;
    }
    const isDatamodelBlockRename = (0, rename_1.isDatamodelBlockName)(position, block, lines, document);
    const isMappable = ['model', 'enum', 'view'].includes(block.type);
    const needsMap = !isDatamodelBlockRename ? true : isMappable;
    const isEnumValueRename = (0, rename_1.isEnumValue)(currentLine, params.position, block, document);
    const isValidFieldRename = (0, rename_1.isValidFieldName)(currentLine, params.position, block, document);
    const isRelationFieldRename = isValidFieldRename && (0, rename_1.isRelationField)(currentLine, lines);
    if (isDatamodelBlockRename || isEnumValueRename || isValidFieldRename) {
        const edits = [];
        const currentName = (0, rename_1.extractCurrentName)(currentLine, isDatamodelBlockRename, isEnumValueRename, isValidFieldRename, document, params.position);
        let lineNumberOfDefinition = position.line;
        let blockOfDefinition = block;
        let lineOfDefinition = currentLine;
        if (isDatamodelBlockRename) {
            // get definition of model or enum
            const matchBlockBeginning = new RegExp(`\\s*(${block.type})\\s+(${currentName})\\s*({)`, 'g');
            lineNumberOfDefinition = lines.findIndex((l) => matchBlockBeginning.test(l));
            if (lineNumberOfDefinition === -1) {
                return;
            }
            lineOfDefinition = lines[lineNumberOfDefinition];
            const definitionBlockAtPosition = (0, ast_2.getBlockAtPosition)(lineNumberOfDefinition, lines);
            if (!definitionBlockAtPosition) {
                return;
            }
            blockOfDefinition = definitionBlockAtPosition;
        }
        // rename marked string
        edits.push((0, rename_1.insertBasicRename)(params.newName, currentName, document, lineNumberOfDefinition));
        // check if map exists already
        if (!isRelationFieldRename &&
            !(0, rename_1.mapExistsAlready)(lineOfDefinition, lines, blockOfDefinition, isDatamodelBlockRename) &&
            needsMap) {
            // add map attribute
            edits.push((0, rename_1.insertMapAttribute)(currentName, position, blockOfDefinition, isDatamodelBlockRename));
        }
        // rename references
        if (isDatamodelBlockRename) {
            edits.push(...(0, rename_1.renameReferencesForModelName)(currentName, params.newName, document, lines));
        }
        else if (isEnumValueRename) {
            edits.push(...(0, rename_1.renameReferencesForEnumValue)(currentName, params.newName, document, lines, blockOfDefinition.name));
        }
        else if (isValidFieldRename) {
            edits.push(...(0, rename_1.renameReferencesForFieldName)(currentName, params.newName, document, lines, blockOfDefinition, isRelationFieldRename));
        }
        (0, rename_1.printLogMessage)(currentName, params.newName, isDatamodelBlockRename, isValidFieldRename, isEnumValueRename, block.type);
        return {
            changes: {
                [document.uri]: edits,
            },
        };
    }
    return;
}
exports.handleRenameRequest = handleRenameRequest;
/**
 *
 * @param item This handler resolves additional information for the item selected in the completion list.
 */
function handleCompletionResolveRequest(item) {
    return item;
}
exports.handleCompletionResolveRequest = handleCompletionResolveRequest;
function handleCodeActions(params, document, onError) {
    if (!params.context.diagnostics.length) {
        return [];
    }
    return (0, code_actions_1.quickFix)(document, params, onError);
}
exports.handleCodeActions = handleCodeActions;
function handleDocumentSymbol(params, document) {
    const lines = (0, ast_1.convertDocumentTextToTrimmedLineArray)(document);
    return Array.from((0, ast_2.getBlocks)(lines), (block) => ({
        kind: {
            model: vscode_languageserver_1.SymbolKind.Class,
            enum: vscode_languageserver_1.SymbolKind.Enum,
            type: vscode_languageserver_1.SymbolKind.Interface,
            view: vscode_languageserver_1.SymbolKind.Class,
            datasource: vscode_languageserver_1.SymbolKind.Struct,
            generator: vscode_languageserver_1.SymbolKind.Function,
        }[block.type],
        name: block.name,
        range: block.range,
        selectionRange: block.nameRange,
    }));
}
exports.handleDocumentSymbol = handleDocumentSymbol;
//# sourceMappingURL=MessageHandler.js.map
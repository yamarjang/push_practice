"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDocumentationForBlock = exports.getCompositeTypeFieldsRecursively = exports.getFieldTypesFromCurrentBlock = exports.getFieldsFromCurrentBlock = exports.getDatamodelBlock = exports.getBlocks = exports.Block = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const constants_1 = require("../constants");
const fields_1 = require("./fields");
const findAtPosition_1 = require("./findAtPosition");
class Block {
    constructor(type, range, nameRange, name) {
        this.type = type;
        this.range = range;
        this.nameRange = nameRange;
        this.name = name;
    }
}
exports.Block = Block;
// Note: this is a generator function, which returns a Generator object.
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*
function* getBlocks(lines) {
    let blockName = '';
    let blockType = '';
    let blockNameRange;
    let blockStart = vscode_languageserver_1.Position.create(0, 0);
    const allowedBlockIdentifiers = ['model', 'type', 'enum', 'datasource', 'generator', 'view'];
    for (const [key, item] of lines.entries()) {
        // if start of block: `BlockType name {`
        if (allowedBlockIdentifiers.some((identifier) => item.startsWith(identifier)) && item.includes('{')) {
            if (blockType && blockNameRange) {
                // Recover from missing block end
                yield new Block(blockType, vscode_languageserver_1.Range.create(blockStart, vscode_languageserver_1.Position.create(key - 1, 0)), blockNameRange, blockName);
                blockType = '';
                blockNameRange = undefined;
            }
            const index = item.search(/\s+/);
            blockType = ~index ? item.slice(0, index) : item;
            blockName = item.slice(blockType.length, item.length - 2).trimStart();
            const startCharacter = item.length - 2 - blockName.length;
            blockName = blockName.trimEnd();
            blockNameRange = vscode_languageserver_1.Range.create(key, startCharacter, key, startCharacter + blockName.length);
            blockStart = vscode_languageserver_1.Position.create(key, 0);
            continue;
        }
        // if end of block: `}`
        if (item.startsWith('}') && blockType && blockNameRange) {
            yield new Block(blockType, vscode_languageserver_1.Range.create(blockStart, vscode_languageserver_1.Position.create(key, 1)), blockNameRange, blockName);
            blockType = '';
            blockNameRange = undefined;
        }
    }
}
exports.getBlocks = getBlocks;
function getDatamodelBlock(blockName, lines) {
    // get start position of block
    const results = lines
        .map((line, index) => {
        if ((line.includes('model') || line.includes('type') || line.includes('enum') || line.includes('view')) &&
            line.includes(blockName)) {
            return index;
        }
    })
        .filter((index) => index !== undefined);
    if (results.length === 0) {
        return;
    }
    const foundBlocks = results
        .map((result) => {
        const block = (0, findAtPosition_1.getBlockAtPosition)(result, lines);
        if (block && block.name === blockName) {
            return block;
        }
    })
        .filter((block) => block !== undefined);
    if (foundBlocks.length !== 1) {
        return;
    }
    if (!foundBlocks[0]) {
        return;
    }
    return foundBlocks[0];
}
exports.getDatamodelBlock = getDatamodelBlock;
function getFieldsFromCurrentBlock(lines, block, position) {
    const fieldNames = [];
    for (let lineIndex = block.range.start.line + 1; lineIndex < block.range.end.line; lineIndex++) {
        if (!position || lineIndex !== position.line) {
            const line = lines[lineIndex];
            const fieldName = getFieldNameFromLine(line);
            if (fieldName) {
                fieldNames.push(fieldName);
            }
        }
    }
    return fieldNames;
}
exports.getFieldsFromCurrentBlock = getFieldsFromCurrentBlock;
function getFieldTypesFromCurrentBlock(lines, block, position) {
    const fieldTypes = new Map();
    const fieldTypeNames = {};
    let reachedStartLine = false;
    for (const [lineIndex, line] of lines.entries()) {
        if (lineIndex === block.range.start.line + 1) {
            reachedStartLine = true;
        }
        if (!reachedStartLine) {
            continue;
        }
        if (lineIndex === block.range.end.line) {
            break;
        }
        if (!line.startsWith('@@') && (!position || lineIndex !== position.line)) {
            const fieldType = (0, fields_1.getFieldType)(line);
            if (fieldType !== undefined) {
                const existingFieldType = fieldTypes.get(fieldType);
                if (!existingFieldType) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    const fieldName = getFieldNameFromLine(line);
                    fieldTypes.set(fieldType, { lineIndexes: [lineIndex], fieldName });
                    fieldTypeNames[fieldName] = fieldType;
                }
                else {
                    existingFieldType.lineIndexes.push(lineIndex);
                    fieldTypes.set(fieldType, existingFieldType);
                }
            }
        }
    }
    return { fieldTypes, fieldTypeNames };
}
exports.getFieldTypesFromCurrentBlock = getFieldTypesFromCurrentBlock;
function getCompositeTypeFieldsRecursively(lines, compositeTypeFieldNames, fieldTypesFromBlock) {
    const compositeTypeFieldName = compositeTypeFieldNames.shift();
    if (!compositeTypeFieldName) {
        return [];
    }
    const fieldTypeNames = fieldTypesFromBlock.fieldTypeNames;
    const fieldTypeName = fieldTypeNames[compositeTypeFieldName];
    if (!fieldTypeName) {
        return [];
    }
    const typeBlock = getDatamodelBlock(fieldTypeName, lines);
    if (!typeBlock || typeBlock.type !== 'type') {
        return [];
    }
    // if we are not at the end of the composite type, continue recursively
    if (compositeTypeFieldNames.length) {
        return getCompositeTypeFieldsRecursively(lines, compositeTypeFieldNames, getFieldTypesFromCurrentBlock(lines, typeBlock));
    }
    else {
        return getFieldsFromCurrentBlock(lines, typeBlock);
    }
}
exports.getCompositeTypeFieldsRecursively = getCompositeTypeFieldsRecursively;
// TODO (JoÃ«l) a regex for \w in first position would be better?
function getFieldNameFromLine(line) {
    if (line.startsWith('//') || line.startsWith('@@')) {
        return undefined;
    }
    const firstPartOfLine = line.replace(/ .*/, '');
    return firstPartOfLine;
}
const getDocumentationForBlock = (document, block) => {
    return getDocumentation(document, block.range.start.line, []);
};
exports.getDocumentationForBlock = getDocumentationForBlock;
const getDocumentation = (document, line, comments) => {
    const comment = document.getText({
        start: { line: line - 1, character: 0 },
        end: { line: line - 1, character: constants_1.MAX_SAFE_VALUE_i32 },
    });
    if (comment.startsWith('///')) {
        comments.unshift(comment.slice(4).trim());
        return getDocumentation(document, line - 1, comments);
    }
    return comments;
};
//# sourceMappingURL=block.js.map